### 为什么 Redis 采用单线程工作模型处理多个客户端的连接还能保持高效率？
* Redis 使用的是单线程 I/O 多路复用的方式给客户端传送数据
* 多线程处理连接主要用于**磁盘 I/O 阻塞**时可以挂起线程，让 CPU 去处理另外的连接。由于 Redis 数据存储在内存中，而在内存中取数据**不会阻塞**，因此不需要多线程。多线程的线程切换甚至为**负优化**
* Redis 在删除数据和网络 I/O 读数据时使用了多线程处理
<br>

### 解释一下 Redis 的 Copy On Write？
* 总体来看，Redis 读多写少，适合 COW
* Redis 在进行持久化操作时，会 fork 子进程读取内存数据并写道磁盘中，由于只是读，因此子进程不会拷贝数据副本
* 若在此时内存中写入大量数据，子进程就需要拷贝副本，耗费时间和内存资源
* 一般在扩容 rehash 时会发生大量写操作，因此当子进程存在时，将负载因子调高，尽量减少扩容 rehash 操作
<br>

### Redis 为什么快？
* 直接操作内存
* 单线程，I/O 多路复用
* 高效的数据结构
<br>

### 五种对象类型和使用场景？
1. string：变长字符串
   * 缓存 json 结构体
   * 缓存计数值。Redis 提供了封装好的计数值自增操作
2. list：链表结构
   * 作为异步队列使用。Redis 的单线程特性保证了队列的线程安全
3. hash：数组加链表的 hashmap，value 只能为字符串
   * 缓存结构体，可取出结构体的某个字段值，而不必将整个结构体取出
4. set：value 为 null 的 hash
   * 去重业务里使用，如每个用户只能中奖一次
5. zset：有序 set， value 存权重，使用跳表实现
   * 排序业务里使用，如各种排行榜
<br>

### 对象类型的数据结构实现？
自定义数据结构：
1. 简单动态字符串，**字符串**实现和 **AOF 缓冲区**
   * 底层 char[]，维护已使用字节数和空闲字节数
   * '\0' 结尾，方便复用 C 函数
   * 面向字节而不是字符，因此**二进制安全**。取串时不会受到中间 '\0' 的影响，而是由**已使用字节数**决定
   * 动态扩容，每次扩容不超过 1MB；封装了请求内存的操作，避免了缓冲区溢出
   * 懒惰内存分配。扩容时通过分配额外空间减少请求内存次数，缩容时通过直接设置空闲字节数和长度，而不是直接 free
2. 双端链表，**列表**的实现之一
3. 字典（底层哈希表），**哈希**实现之一，**数据库**实现
   * 一个字典有两个哈希表，多出来的一个用于 rehash
   * 链式地址解决 hash 冲突
   * 渐进式 rehash，每一次增删查改仅仅 rehash 一个桶
   * rehash 过程中增数据只在新表中进行，删查改则需要检索两个表
4. 跳表，**有序集合**实现之一
5. 整数集合，**集合**实现之一
   * 只存储 8 位、16位、32 位、64 位整数，且数量不大时，使用此结构实现
   * 底层数组实现，数据有序连续存储
   * 升级机制：一开始存储 int_8，当插入数据大于 127 或小于 -128 时，升级为 int_16，重新分配内存并转移数据
   * 无降级机制
6. 压缩列表，**列表**和**哈希**实现之一
   * 列表项少、哈希键值对少，每项数值小或字符串长度短，则使用压缩列表
   * 连续节点项，数组实现
   * 每一项都使用 1 字节或 5 字节记录了上一项的长度，这也导致了：当一项长度变化时，其下一项的**记录长度**的字节数可能变化，从而引起连锁的内存重分配
<br>

### 键值对过期如何清理？
* redisDB 结构中除了有代表整个数据库的字典，还有一个维护过期时间的字典，其中存放了**键-过期时间**键值对，通过这个结构可以查看键值对是否过期
* 三种删除策略
  * 创建 timer 定时删除
  * 查询时再检查过期情况的惰性删除
  * 自定义程序定期进行删除
<br>

对象类型的数据结构实现：
1. 字符串对象：long、简单动态字符串、和本对象内存地址连续的简单动态字符串（可通过一次 malloc 分配这个对象的内存空间，而不需要先分配字符串对象的内存，再分配该对象中指向数据结构的指针的内存）
2. 列表对象：压缩列表、双端列表
3. 哈希对象：压缩列表、字典
4. 集合对象：整数集合、字典
5. 有序集合：压缩列表、字典 + 跳表
<br>

### Redis 持久化方案对比？
1. RDB 方式：**默认**的**快照**型持久化方式。<br>
   触发时机：（以下情况都可触发）
    * 执行 save 或 bgsave 命令
    * 执行 flushall 命令
    * 主从复制时
    * 自定义规则：```save {time} {count}```，time 时间内 count 个键发生更改，则触发
    <br>

    触发过程：
    * 主进程 fork 新进程将内存数据持久化入临时文件（Copy On Write）
    * 使用临时文件替换原 rdb 文件
    <br>

    优点：
    * 数据量小时持久化快
    * 使用 rdb 文件进行数据恢复时速度快
    * 文件为压缩后的二进制文件，体积小
    <br>

    缺点：
    * 数据量大时子进程可能阻塞主进程
    * RDB 频率低，会丢失最后一次快照之后的数据
2. AOF 方式：**逻辑**型持久化方式。<br>
   触发时机：（通过配置选择其一）
   * 每次执行写入时
   * 每秒一次
   * 不主动执行，交由操作系统决定
   <br>

   触发过程：
   * 主进程将指令写入 aof 文件
   * aof 文件大小达到阈值时，fork 子进程创建新文件维护**最小命令集合**（能达到当前内存状态的最少命令，会删去对键的覆盖赋值）
   * 重写过程中父进程将新指令放入 **AOF 重写缓冲区**中
   * 用新文件替换旧 aof 文件
   * 父进程将缓冲区内指令持久化入新文件
    <br>

    优点：
    * 触发频繁，数据安全，崩溃恢复损失数据少
    * aof 文件可读性强，可在重写前人工回滚操作
    <br>

    缺点：
    * 恢复速度慢
    * 文件体积大
3. 混合模式<br>
   fork 子进程进行 RDB 持久化，持久化过程中使用 AOF 缓冲区存储新指令，持久化完毕后进行 AOF 缓冲区的追加持久化。
<br>

### 缓存雪崩 / 缓存穿透 / 缓存击穿及其解决方案？
1. 缓存雪崩<br>
   大量缓存同时到期，同时大量请求到来，直接打到数据库上，使数据库崩溃。<br>
   解决方案：
   * 为每个 key 的过期时间设置一个随机值偏移，防止同一时间出现大量数据过期
   * 将热点数据分散在不同 Redis 库中，不同库中的 key 一般不会同时大批量过期
   * 设置热点数据为永不过期，需要更新时手动更新。
2. 缓存穿透：<br>
   不断请求缓存和数据库中都没有的数据，增大数据库压力，如查询 id < 0 的数据。<br>
   解决方案：
   * 接口层增加用户校检、参数校检等
   * 缓存中加入 key-null 对，将后续访问压力移至 Redis
   * 网关层限制单个 ip 的单位时间访问次数
   * 使用 Redis 的 Blomm Filter 快速判断数据库中是否有 key
3. 缓存击穿<br>
   单个 key 访问量较大，该 key 失效时大量请求打入数据库造成数据库崩溃。<br>
   解决方案：
   * 设置 key 永不过期
   * 加互斥锁，获取锁成功的线程去数据库取数据并更新缓存，获取锁失败的线程则休眠一段时间后重新读缓存
<br>

### Redis 大 key 会引起什么问题，如何解决？
出现问题：
* 大 key 占用空间大，在分片的 Redis 集群中，若无主从设计，则存储该 key 的实例内存使用量会大于其他实例，拖累整个集群的使用
* 大 key 传输数据量大，读时会产生流量激增，遇到网络传输瓶颈
* 大 key 操作时间长，对大 key 的删除操作会更容易阻塞请求
<br>

解决方案：
* 拆 key。将单个 key-value 拆分为多个 key-value 存入不同实例
* 换数据库。Redis 不适合存储大 key，可以考虑用 MonogoDB
* 堆资源。使用一主多备方式提高可用性
<br>

### Redis 如何实现分布式锁？
单机 Redis 锁：
1. 使用 ```setnx```、```setex``` 将加锁原子化：判断是否有键值对，如果有这个键值对，则什么都不做，获取锁失败，否则添加键值对，获取锁成功。后者可设置失效时间。
2. 使用 ```Lua 脚本```将解锁原子化：根据 value 判断当前键值对是否为本线程设置的，如果是，则删除键值对解锁，否则说明自己的锁已过期，什么都不做。
<br>

集群 Redis 锁：使用 redisson 包的 redlock 锁。
<br>

### Redis 与数据库的同步问题？
1. 为缓存 key 设置过期时间。
   * 优点：实现简单，零成本
   * 缺点：脏数据会很多
2. 设置过期时间，更新 DB 时同时更新 Redis。
   * 优点：一定程度上缓解了更新延迟
   * 缺点：服务需要同时连接 DB 和 Redis，增加连接数
3. 在 2 的基础上增加消息队列，更新 Redis 交由消息队列保障。
   * 优点：减少了连接数，消息队列提供可靠性
   * 缺点：无法保证 Redis 更新时序和 DB 时序一致
4. Redis 端搭建 DB slave，通过拉取 binlog 的方式更新 Redis。
   * 优点：保证了时序性
   * 缺点：相当于多了个 DB，成本大
<br>

### 说一下 Redis Cluster 集群模式的工作原理？
1. 自动分为多个 master 片，每个片上放一部分数据，无中心，不需要代理。
   * 没有使用普通 hash 来分片（不利于拓展），也没有使用一致性 hash + 虚拟节点，而是使用了 hash slot 算法：预先开 **16384** 个hash slot，每个片缓存不同 slot 的数据。一个片的主从都宕机了，可以配置为整个集群不可用，也可以配置为其他 slot 可用
   * 访问某个节点时，若数据不在此节点上，该节点会给出正确节点的链接
   * 每个片开两个端口，一个提供服务，另一个用于片间通讯（故障检测、配置更新、故障转移授权），后者端口号是（前者端口号 + 10000）
   * 集群元数据维护、片间通讯使用二进制协议 **gossip**。比起使用 zookeeper 管理的集中式维护方法，gossip 协议是传递性的，元数据更新不会打在一个点，而是分散陆续打在每个片上，降低了压力，但降低了一致性
   * 片之间定期发送 **ping** 并回复 **pong**，来判断是否故障、交换故障信息、节点增删信息、hash slot 信息等元数据。ping 间隔过长，会降低一致性；间隔过短，会增大网络负担
2. 每个片提供内置高可用支持，每个 master 可设置多个 slave 备份。主从切换类似哨兵原理。
   * 判断主节点宕机。其他任意主节点 ping 这个节点，在规定时间内没有收到回应 pong，则认为该节点**主观宕机**。发现该节点宕机的节点在和其他主节点 ping 时会传递这个信息。超过半数主节点都认为该节点主观宕机后，则该节点**客观宕机**
   * 从节点过滤。正常的主节点连接【宕机的主节点的从节点】，检查它们和自己的 master 断开连接的时间，若超过阈值则说明该从节点数据严重不一致，没有资格升级为 master
   * 从节点选取。从节点们根据自己复制了主节点数据量多少来进行自荐，复制多的排名靠前。未宕机的 master 对这些从节点进行投票，半数通过
<br>

***

##
部分来源：<br>
https://imageslr.com/2020/07/08/tech-interview.html<br>
https://zhuanlan.zhihu.com/p/374078040<br>
https://cloud.tencent.com/developer/article/1444057<br>
