### 多服务器节点下 Session-Cookie 方案如何做？
1. 按用户哈希分配服务器，同一个用户的请求只会到同一个服务器上。若该服务器宕机，则 session 丢失。
2. 所有服务器保存全量 session。需要服务器间同步，成本大。
3. 单独使用一组所有服务器都能访问到的节点（如 Redis 缓存）来存放 session 信息。
<br>

### 网关有什么用？
* 协议转换：外部 HTTP 和内部 RPC 互转
* 请求路由、负载均衡
* 统一鉴权：解耦鉴权和业务逻辑
* 日志监控
* 流量控制、熔断降级
<br>

### 分布式系统中用来标识消息的唯一 id 如何生成？
1. 数据库自增。
   * 单独配置一个数据库用于生成 id，需要 id 时都要从该数据库中插入随机数据并生成唯一 id
   * 效率低，可用性低
2. 数据库多主模式。
   * 多个数据库独立生成 id，每个 id 自增间隔为数据库数目
   * 有一定可用性
   * 需要添加一层负载均衡，且难以不停机拓展
3. 号段模式。
   * 加一层缓存集群，每个缓存单体向数据库请求一段 id。需要 id 时向缓存请求
   * 拓展方便，有一定可用性
   * 缓存宕机会造成部分 id 丢失浪费
4. 雪花算法。
   * 将 64 位 long 分割，首位符号位为 0，41 位时间戳，10 位机器编号，12位序列号（一个时间戳内能生成的最大 id 数量）
   * 不依赖数据库
   * 机器编号的分配比较困难，可以用数据库自增的方式获取机器编号
<br>

### 有哪些负载均衡算法？
轮询、加权轮询、负载最低优先、性能最优、hash
<br>

### 消息队列有什么作用？
1. 通过异步处理减少响应时间。当消息推到队列中后直接返回，而不需要等消息被消费。
2. 削峰限流。大量请求打到消息队列的输入上，而消息队列的输出保持平稳，作为消费者的业务系统接收到的是平稳的请求。
3. 降低系统耦合性。发布-订阅模式中，解除消息生产者和消费者的耦合，方便拓展。
<br>

### 消息队列会带来哪些问题？
1. 降低可用性。需考虑消息队列宕机了怎么办。
2. 提高复杂性。需考虑消息能够被重复消费、消息丢失怎么办、消息消费的顺序性等问题。
3. 降低一致性。消息消费过程出现错误，会导致消息生产者和消费者的不一致。
<br>

### 分布式事务怎么实现？
1. 2PC（Two-phase commit protocol）
   * 引入**事务协调者**，保证**强一致性**
   * 阶段：
     * **准备阶段**：协调者向所有参与者**同步**发送准备命令，参与者进行提交事务的各种准备（锁定资源，写日志等），返回成功或失败
     * **回滚阶段**：有一位参与者返回了失败，则协调者向所有参与者不断发送回滚命令，直到回滚成功
     * **提交阶段**：所有参与者返回成功，则协调者向所有参与者不断发送提交命令，直到事务提交成功
   * 缺点：
     * **同步阻塞**，事务提交方在每个阶段都会阻塞，锁定资源
     * **单点故障问题**，协调者挂掉，就很难保证一致性了
     * **数据库层面**的事务，而非业务层面的事务，需要事务协调者掌握整个事务信息。若业务需求涉及多个服务，服务之间数据库层又不是互通的，那么就没有一个协调者能够获得全部的事务操作，多个服务无法合并成一个事务
   * 实现方式：
     * 利用本地数据库的 XA 两阶段提交协议
     * 阿里开源框架 Seata，低侵入性，改进了锁资源的做法
       * Transaction Manager：嵌入应用中，负责开启全局事务，决定全局提交或全局回滚
       * Transaction Coordinator：独立中间件，负责接收 TM 命令，协调 RM，维护事务运行状态
       * Resource Manager：控制分支事务，负责分支注册、状态汇报、接收 TC 命令，驱动本地事务提交回滚
2. 3PC
   * 参与者引入超时机制（2PC 只有协调者有超时机制）
   * 阶段：
     * **准备阶段**：协调者询问所有参与者是否有提交事务的条件
     * **预提交阶段**：同 2PC 准备阶段
     * **提交阶段** 同 2PC
   * 一定程度上缓解了因协调者挂掉导致参与者阻塞不释放资源的问题，但数据更加可能不一致了
3. TCC（Try-Confirm-Cancel）
   * **业务层面**的事务，可跨服务。需要为每一个服务编写独立的 try、confirm、cancel
   * 阶段：
     * **try**：事务调用者发起事务，并依次调用参与者的 try，进行资源的预留和锁定
     * **confirm**：try 阶段全部返回 ok，调用 confirm 提交事务
     * **cancel** ：try 阶段有至少一个不 ok，调用 cancel 释放预留的资源
   * 缺点：
     * 与业务紧耦合
     * 三个方法都需要考虑网络拥堵状况，需要解决幂等、空回滚（try 丢失，cancel 直接返回）、悬挂（try 晚于 cancel 执行）等问题
4. 本地消息表
   * 利用了本地事务，保证**最终一致性**
   * 过程：
     * 在一号参与者的本地数据库新建一张消息表
     * 一号参与者执行事务：原本事务逻辑 + 其他参与者事务消息写入消息表
     * 立刻去调用其他参与者的事务逻辑/本地线程定期扫描消息表中未成功的消息并调用其他参与者事务（需要实现幂等性）
     * 其他参与者执行完事务后，回调一号参与者，修改消息表中对应消息为成功/一定次数后失败报警
5. 消息事务
   * 使用 RocketMQ 提供的半消息（订阅方不可见的消息）实现，保证**最终一致性**
   * 过程：
     * 一号参与者发送事务半消息到 MQ
     * MQ 返回发送成功，一号参与者执行事务
     * 一号参与者发送 commit/rollback 到 MQ，MQ丢弃半消息或补全半消息。MQ 还会定时回调一号参与者函数，检查一号参与者的事务执行情况
     * 其他参与者收到事务全消息，执行各自事务（通过幂等性防止重复消费）
     * 若其他参与者执行事务成功，则消费消息
6. 最大努力通知
   * 保证**最终一致性**，消息队列实现，消息接收者主动向消息发送者确认事务情况来保证一致性。需要消息发送者实现一致性检验的接口
   * 适合时间敏感度低的业务，如充值后短信通知，充值服务尽最大努力通知短信服务，短信服务主动向充值服务确认充值状态
<br>

***
##
参考链接：<br>
https://zhuanlan.zhihu.com/p/183753774<br>
https://zhuanlan.zhihu.com/p/263555694<br>