# 数据库

## 基础知识

### B树/B+树

[B+ Tree](./ref/B+Trees.pdf "B+ Trees")
B树：多路树，每一个节点都包含多个键（索引）和指针，每一个节点都是data page
B+树：多路树，节点包括data page与index page，叶子节点都是data page
  
聚集索引（主键）
二级索引（一般的索引、唯一索引、组合索引）
[MySQL 索引](https://www.cnblogs.com/zsql/p/13808417.html#_label0)
  
索引设计

* 索引字段短，数字类型
* 索引字段不要为NULL
* 前缀索引（Text）
* 索引选择性
* 组合索引最左前缀
  
Query语句执行顺序
FROM和JOINs --> WHRE --> GROUP --> HAVING --> SELECT -> DISTINCT -> ORDER BY --> LIMIT/OFFSET

## 存储引擎

### MySQL有哪些存储引擎？

1. InnoDB：最广泛使用的存储引擎，支持事务，行级锁，外键完整性约束，崩溃恢复，MVCC。
2. MyISAM：快速的存储引擎，不支持事务，只支持表级锁。
3. Memory：在内存中创建数据，速度最快，不支持事务，只支持表级锁。适合快速查询或临时表场景。
4. CSV：将数据存储为 CSV 格式，可被其他应用读取。
5. Merge（MRG_MyISAM）：MyISAM 表的组合，更容易处理大批量数据，一般用于数据仓库的管理（如日志处理）。
6. Archive：会对插入数据进行压缩，只支持插入和查询，适合归档用。
7. Blackhole：接收请求并进行处理，但不存数据，查询永远返回空集，可用于性能测试。
8. Federated：将多个物理数据库集合为一个逻辑数据库，本地服务器上的查询将在远程数据库中自动执行。适用于分布式场景。
9. Example：只能创建表，不能存取数据，可以用来学习编写新的存储引擎。

### InnoDB, MyISAM, Memory对比？

||InnoDB|MyISAM|Memory|
|:---:|:---:|:---:|:---:|
|存储文件|表结构文件 ```.frm```  数据和索引文件 ```.idb```|表结构文件 ```.frm```  数据文件 ```.MYD```  索引文件 ```.MYI```|表结构文件 ```.frm```|
|索引存储结构|B+ 树，聚簇索引|B+ 树，非聚簇索引（二级索引，辅助索引）|hash|
|数据存储位置|主键树的叶子节点存放完整的行数据  普通索引树的叶子节点存放索引值和主键值|与索引分离，索引的数据区存放行指针（偏移）|内存中|
|存储物理结构|文件表分为段（segment），段分为区（extent），区分为页（page）  每页存放一个 B+ 树节点，相邻节点的页物理上不必连续|行在文件中连续存储，用偏移量来定位|-|
|事务|支持|不支持|不支持|
|锁机制|支持行锁，并发更新处理优秀|只支持表锁|只支持表级锁
|外键|支持|不支持|不支持|不支持|
|全文索引|需要使用插件|支持|不支持|
|读|需要维护 MVCC，可能有回表，寻址要从区到页再到行，慢|无回表，寻址快|快|
|写|需要维护日志，MVCC，慢|快，但受表锁影响大|快|
|空间占用|有日志，大|索引能压缩，小|-|
|数据恢复能力|可通过日志安全恢复|只能人工备份恢复|无|

## 事务

### 事务的 ACID 特性是什么？

* 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成。事务执行过程中出错，则回滚到事务开始前的状态。
* 一致性：一个事务可以封装状态的改变。即事务必须始终保证系统处于一致的状态，数据完具有完整性。例如，5个银行账户，无论并发多少个转账事务，这5个账户内的金额总数必须不变。
* 隔离性：隔离状态执行事务，使它们好像是系统在给定时间内而唯一执行的事务，同一时间只能有一个事务访问同一个数据。又称为串行化。
* 持久性：事务完成后，更改会持久地保存在数据库中，不会被回滚，即提交的事务一定能被保存。

### 数据库如何实现事务的四个特性的？

1. 通过 **undo log** 实现原子性。
   * undo log 记录逻辑语句，回滚时执行对应语句的逆向操作。
2. 通过 **redo log** 实现持久性。
   * 数据在内存中更改后，首先写入实际数据到 redo log 并将 redo log 写入磁盘中，然后再提交事务，并在 redo log 中标记该事务为提交。实际数据持久化进度由 redo log 的 checkpoint 控制，checkpoint 位置不超过最后一次提交的事务。
   * redo log 进行数据持久化入库的过程是原子的，因为其单位块为 512 字节，和磁盘扇区一致。整个块能原子地持久化入磁盘中。
3. 通过**锁**、**时间戳**和 **MVCC** 实现隔离性。MVCC 是依靠 undo log 实现的
   * 通过写锁，来实现并发写事务的隔离；通过 **间隙锁** 解决幻读；如果一个事务需要读后写，则可以显式为读操作加互斥锁 ```for update```
   * 通过 MVCC 实现只读事务的隔离，不需要获取任何锁
4. 通过**键**约束保证一致性。

### redo log 的二次提交解决什么问题？具体流程？

解决单个数据库 redo log 和 bin log 的**一致性**问题，进一步保证分布式数据库的一致性，因为分布式数据库的一致性是通过同步 bin log 来保证的。

* 所有数据库中持久的数据应该以 bin log 为准，bin log 未记录的，数据库中不应该存在相应数据；bin log 有记录的，数据库必须在未来要完成这条记录的持久化
* bin log 无法实现崩溃恢复，因为它只做记录，不进行实际数据刷盘持久化过程，因此不知道实际持久化的进度达到自己记录的哪个位置了
* redo log 就是用来持久化的，它存有修改的**物理数据**，它用来将数据刷盘至数据库，掌握着数据库持久化的实际进度。但由于它的空间大小限制（循环空间），无法掌握整个数据库群的进度。
* redo log 的二次提交，就保证了 bin log 的逻辑数据一定在 redo log 里有物理数据，同时告诉了 redo log 应该按照 bin log 的记录进行 commit，bin log 记录到哪，它就 commit 到哪

流程：

1. prepare：在内存中更改数据，将更改的数据具体内容存入 redo log，并完成 redo log 文件的持久化，redo log 文件中记录这个事务状态为 **prepare**。
2. commit：将 sql 逻辑写入 bin log，并完成 bin log 文件的持久化，接着将 redo log 对应的事务状态设置为 **commit**，再刷一次盘。此时 bin log 和 redo log 的进度是**一致的**，但数据库中的持久化进度可能还很落后，具体进度用 redo log 文件中的 checkpoint 指针来表示。
3. 若在二次提交过程中崩溃了，就可以利用 redo log 的两个状态，保证 redo log 的进度向 bin log 看齐。具体来说：
   * 从 checkpoint 处开始遍历 redo log，若事务已被标记为 commit，则说明 bin log 中已经有了这条记录，其他所有数据库也都认同这个 bin log 进度，大家是一致的
   * 若事务未被标记为 commit，但 bin log 中已经有了对应事务的记录，则说明其他数据库认为应该有这条记录，但崩溃的数据库的 redo log 没提交事务。虽然 redo log 存有这个事务的物理数据，但由于没提交，不能把这条记录持久化入数据库。此时需要在 redo log 中把事务重新设置为 commit
   * 若事务未被标记为 commit，且 bin log 也没有对应事务的记录，说明其他数据库群不认同这条记录，那么崩溃服务器的 redo log 只需要将还处于 prepare 状态的事务的数据删除即可

## 优化

### 数据库有哪些优化方法？

1. SQL 语句优化
2. 索引优化
3. 数据库部署优化
   * 主从分离
   * 读写分离
4. 数据库拆分
   * 分库
   * 分表
5. 系统配置优化、硬件优化

## 分布式

### 分库分表后如何做数据迁移？

1. 停机迁移
2. 不停机**双写**迁移
   * 新的增删改同时写入新老数据库
   * 逐个对比新老数据库数据，进行同步

***

部分来源  
<https://imageslr.com/2020/07/08/tech-interview.html>
<https://draveness.me/mysql-transaction/>
