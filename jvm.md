# JVM

## 分区

程序计数器、堆、栈、方法区

程序计数器：下一条指令位置  
栈：栈帧组成，包括局部变量（8个基本类型、对象引用、返回类型）、操作栈、方法出口、动态连接（动态连接控制着运行时常量池和栈帧的连接。所有方法和类的引用都会被当作符号的引用存在常量池中）  
堆：GC  
![heap](pic/heap.png)  
方法区：用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据

### 哪些区会发生 OOM？

1. 堆内存溢出：内存泄漏或堆大小设置不当导致。
2. 方法区溢出：class 信息过多，如 cglib 的反射、jsp 文件的编译都会产生大量 class。运行时常量池溢出也属于方法区的溢出，但表现在堆上，如 String.intern() 方法不断创建 String 常量。
3. 栈溢出：线程请求栈深度大于最大设定值时，会抛出 StackOverflowError；栈拓展时无法申请到要拓展的内存，则会抛出 OOM。
4. 直接内存溢出：JVM 外的内存溢出，比如 NIO 的 native 方法分配的堆外内存。

### 为什么会有堆外内存？

* 位于 JVM 外部，受操作系统管理，相当于内核态的内存，I/O 时**省去了堆内和堆外数据拷贝**的步骤，效率高，适合做为缓冲池来使用
* 非 full gc 不会清理这部分内存，提高 gc 效率，同时也提高了对这部分内存的操作的效率（不会被 gc 整理到其他位置去）

---

## GC

1. Partial GC：收集部分GC堆
   * Young GC：young gen的GC
   * Old GC：old gen的GC（CMS）
   * Mixed GC：yong gen与部分old gen的GC（G1）
2. Full GC：整个所有堆

### 虚引用和弱引用、软引用的区别？

虚引用**必须**和一个引用队列相关联，当引用的对象被回收**之前**，虚引用会进入这个队列。而弱引用和软引用则不必须和引用队列关联。

### 不可达对象一定会被回收吗？

1. 若对象没有覆盖 finalize 方法，或 finalize 方法已经被执行过，则被回收。否则执行 finalize 方法并重新放入二次标记队列中。
2. 若 finalize 方法使对象重新进入引用链，则对象被标记，逃脱死亡的命运，否则被回收。

### 类对象可以被回收吗？

当一个类对象

* 所有实例被回收
* clazz 不被引用
* ClassLoader 被回收

时，虚拟机可以对这个类对象回收，但不是一定要回收。

### HotSpot 为什么要分新生代和老年代？

规律：新对象有很大概率生命周期很短；已经活过很久的对象很大概率会继续活很久。

1. 新生代用来存放新对象，活过 gc 的对象少，因此使用复制算法来筛选出**少量**存活的对象。
2. 老年代用来存放寿命长的对象，死于 gc 的对象少，因此使用标记整理/清除算法来筛选出**少量**死亡的对象。

### 有哪些垃圾回收器？

1. Serial、Serial Old
   * 单线程收集器，工作时只能 STW
   * 新生代复制，老年代标记整理
2. ParNew
   * Serial 的多线程版本，工作时只能 STW
3. Parallel Scavenge、Parallel Old
   * 多线程收集器，新生代复制，老年代标记整理
   * 追求高吞吐量，适合交互弱的后台
4. CMS
   * 追求最短 STW，适合于用户交互系统
   * 并发收集器，可与用户线程同时工作
   * 标记清除
   * 流程：（三色标记）
     * 初始标记，STW，标记与 root 直接相连的对象，标记为**灰色**，意为该对象被标记，但其引用树上的对象还未被标记完
     * 并发标记，同时开启用户线程和 GC，标记间接相连的对象，并通过**写屏障**记录本过程中用户线程更改的引用结构。取所有灰色标记，标记其引用的对象（染灰），然后将该对象标记为**黑色**
     * 重新标记，STW，重新标记上阶段新加入引用链的对象。时间长于第一阶段，远短于第二阶段。直至无灰色对象
     * 并发清除，同时开启用户线程和 GC，对未标记的**白色**对象进行清理
   * 缺点：
     * 并发标记阶段会占 CPU 资源
     * 并发清除阶段新产生的垃圾无法清理**浮动垃圾**，即已经标记为黑色的对象成为了垃圾，但并不会回退为白色，因此此次 gc 无法回收这部分垃圾
     * 标记清除会产生大量空间碎片
5. G1（Garbage First 估计每个Region中的垃圾⽐比例例，优先回收垃圾多的Region）
   * 分区：Eden、Survivor、Old、Humongous
   * 年轻代：STW、Copy、Parallel
   * 老年代：Mostly-concurrent marking、Incremental compaction
   * 适合于多处理器大容量内存的服务器，能设置参数来调节 STW 和 吞吐量的平衡
   * 能充分使用多核 CPU 来降低 STW，有毫秒级的 STW 时间模型
   * 不依赖分代，而是将整个堆分为不同区块，回收时按照 STW 期望时间选择回收优先级最高（回收价值最大）的区块
   * 整体上使用标记整理，局部使用复制算法

### 如何回收堆外内存？

堆外内存的引用（指针）被 JVM 堆上的对象持有（冰山对象），线程栈通过持有堆内的对象，间接操作堆外内存。对堆外内存的回收，也就是在 gc 回收堆内对象时，手动释放对象持有的堆外内存。

1. 在堆内对象的析构方法中释放。（不推荐）
2. 通过虚引用监控堆内对象的回收，并同时回收堆外内存。Java 提供了 Cleaner 类，通过虚引用绑定对象，并注册回收时的回调函数，来简化这种操作。

## 类和对象

### new 的过程？

1. 类加载检查
2. 分配内存
   * 保证线程安全
     * TLAB：预先在堆上为每个线程分配一块空间，记录下来，线程需要堆内存时首先在 TLAB 空间上分配
     * CAS 自旋：超过 TLAB 的部分，使用 CAS 自旋的方式分配堆上内存
   * 指针碰撞法：适合内存规整的情况（标记整理、复制算法的 gc），直接将分界点指针移动对象大小即可
   * 空闲列表法：适合内存不规整的情况（标记清除）
3. 初始化零值
4. 设置对象头
5. 执行 init 方法

### 引用是如何定位堆上的对象的？

1. 句柄方式
   * 堆上维护句柄表，栈上引用指向句柄是稳定不变的
   * 内存位置变动时只需要更新句柄表即可
2. 直接指针
   * 栈上引用直接指向对象
   * 少一次指针定位开销

### 类加载过程？

各个阶段交叉进行

1. 加载
   * 通过全限定名获取类的二进制字节流
   * 将字节流转化成方法区中运行时类的数据结构
   * 在内存中生成类对象
2. 验证
   * 文件格式验证：验证是否符合 class 文件规范、版本号、常量类型是否支持等
   * 元数据验证：语义分析，如类是否继承了 final 类、是否有父类等
   * 字节码验证：验证控制流是否合法合逻辑
   * 符号引用验证：解析符号引用的准备工作
3. 准备
   * 基本类型赋 0 值
   * 引用类型赋 null
   * 数组类型不由类加载器加载，而由虚拟机直接创建
4. 解析
   * 将类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用限定符这几类符号引用替换为直接引用
5. 初始化
   * 执行静态的 init 方法
6. 卸载
   * 类对象被回收
